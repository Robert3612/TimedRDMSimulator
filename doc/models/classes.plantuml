@startuml
!define ABSTRACT &#123;abstract&#125;

class TimedRDMSim
{
  + int getSimTime()
  + void run()
  + void runStep(int t)
}

note left of TimedRDMSim::run
  for sim_time_range:
    for(p in probes): p.print()
    n.timeStep()
end note

class Effector
{
  + setMirrors(int m, int t)
  + setStrategy(TopologyStrategy strategy, int t)
  + setTargetLinksPerMirror(int numTargetedLinks, int t)
  + setDataPackage(int mirrorId, DataPackage dataPackage, int t)
  + setDataUpdateStrategy(DataUpdateStrategy dataUpdateStrategy, int t)
  + setDirtyFlagUpdateStrategy(DirtyFlagUpdateStrategy dirtyFlagChange, int t)
  + timeStep(int t)
}

class IDGenerator
{
  - {static} IDGenerator instance
  - IDGenerator()
  + {static} IDGenerator getInstance()
  + int getNextID()
}

class Network
{
  - Properties props
  - int numTargetMirrors
  - int numTargetLinksPerMirror
  ---
  + void registerProbe(Probe p)
  + void setEffector(Effector e)
  ---
  + int getNumTargetMirrors()
  + int getNumReadyMirrors()
  + int getNumMirrors(int m, int t)
  ---
  + void timeStep(int t)
}

abstract class DirtyFlagUpdateStrategy
{
  # Map<DirtyFlag, Map<Integer, Integer>> dirtyFlagAppearance
  + {abstract} void updateDirtyFlag(List<Mirror> mirrors, Network n, Integer simTime)
  # void setupMirror(Mirror m)
}

class HighestFlagAllAtOnce
{
  + void updateDirtyFlag(List<Mirror> mirrors, Network n, Integer simTime)
}

class HighestFlagPerTimestep
{
  + void updateDirtyFlag(List<Mirror> mirrors, Network n, Integer simTime)
}

note right of Network::timeStep
  e.timeStep()t
  for(m : mirrors): m.timeStep(t)
  for(p : probes): p.update(t)
end note

abstract class Probe
{
  + {abstract} void update(int t)
  + {abstract} void print(int t)
}

interface VisualizationStrategy {
    void init(Network network)
    void updateGraph(Network network, long timeStep)
}

class GraphVisualization


class MirrorProbe
{
  - double mirrorRatio
  + void update(int t)
  + void print(int t)
  + int getNumMirrors()
  + int getNumReadyMirrors()
  + int getNumTargetMirrors()
  + double getMirrorRatio()
}

class DirtyFlagProbe
{
  - List<DirtyFlag> dirtyFlagList
  - DirtyFlag highest
  - double FlagRatio
  + void update(int t)
  + void print(int t)
}


enum MirrorState {
  down
  starting
  up
  ready
  stopping
  stopped
  hasdata
}

enum LinkState {
  inactive
  active
  closed
}

class Mirror
{
  - int id;
  - init_time;
  - startup_time;
  - ready_time;
  - stop_time;
  + void shutdown()
  + void timeStep()
}

class Link
{
  - int id
  - init_time
  - ends_active_time
  - activation_time
  + void shutdown()
  + void timeStep(t)
}

class DataPackage
{
  - boolean invalid
  + int getDirtyFlag()
  + List<String> getData()
  + boolean isLoaded()
}

class DirtyFlag{
  - List<Integer> flag
  + int compareFlag(List<Integer> otherFlag)
  + boolean equalDirtyFlag(List<Integer> otherFlag)
  + String toString()
}

class Data
{
  - int fileSize
  - int received
  - int content
  + void increaseReceived(int amount)
  + boolean isLoaded()
}

interface DataUpdateStrategy
{
  + int updateData(Mirror m, Network n)
  + boolean updateRequired(Mirror m, Network n);
}

abstract class ConnectedDataUpdateStrategy
{
  # boolean setZero
  # DirtyFlag setZeroWhen
  + boolean updateRequired(Mirror m, Network n)
  # boolean checkLinks(Link l)
  # void checkLength(DataPackage data1, DataPackage data2)
  # DataPackage doNormalUpdate(DataPackage data1, DataPackage data2, int bandwidth)
}

class DeltaDataUpdateStrategy
{
  + int updateData(Mirror m, Network n)
  - int deltaUpdate(Mirror m, Mirror m2, Link l)
}

class FullDataUpdateStrategy
{
  + int updateData(Mirror m, Network n)
  - int fullUpdate(Mirror m, Mirror m2, Link l)
}

class LinkProbe
{
  - double ratio
  + void print(int t)
  + void update(int t)
}

interface TopologyStrategy
{
    + Set<Link> initNetwork(Network,Properties)
    + void handleAddNewMirrors(Network,newMirrors,Properties)
    + void handleRemoveMirrors(Network,removeMirrors,Properties)
    + int getNumTargetLinks(Network)
}

abstract class Action{
- int id
- int time
- Network network
+ void run(Network, t)

}

class Effect{
}

class DataPackageChange{
- int mirrorId
- DataPackage package
}

class DataUpdateChange{
- DataUpdateStrategy dataUpdateStrategy
}

class DirtyFlagChange{
- DirtyFlagUpdateStrategy dirtyFlagUpdateStrategy
}

class MirrorChange{
- int newMirrors
}

class TargetLinkChange{
- int newLinksPerMirror
}

class TopologyChange{
- TopologyStrategy newTopology
}

class BalancedTreeTopologyStrategy

class FullyConnectedTopologyStrategy

class NConnectedTopology

TopologyStrategy <|.. BalancedTreeTopologyStrategy
TopologyStrategy <|.. FullyConnectedTopologyStrategy
TopologyStrategy <|.. NConnectedTopology
VisualizationStrategy <-- TimedRDMSim
VisualizationStrategy <|. GraphVisualization
TimedRDMSim --> Effector
TimedRDMSim --> "*" Probe
Network --> TopologyStrategy
Network --> DirtyFlagUpdateStrategy
Network <--> Effector
Network *--> "*" Mirror
Network *-> "*" Link
Network <--> "*" Probe
IDGenerator <-- Network
Mirror -> MirrorState
Mirror *--> Link
Mirror --> DataPackage
Mirror --> DataUpdateStrategy
Link -> LinkState
Link --> "source" Mirror
Link --> "target" Mirror

DataPackage *--> Data
DataPackage --> DirtyFlag

Probe <|-- MirrorProbe
Probe <|-- LinkProbe
Probe <|-- DirtyFlagProbe

DirtyFlagUpdateStrategy <|-- HighestFlagAllAtOnce
DirtyFlagUpdateStrategy <|-- HighestFlagPerTimestep

DataUpdateStrategy <|.. ConnectedDataUpdateStrategy
ConnectedDataUpdateStrategy <|-- FullDataUpdateStrategy
ConnectedDataUpdateStrategy <|-- DeltaDataUpdateStrategy
TimedRDMSim -> Network
Action <|-- DataPackageChange
Action <|-- DataUpdateChange
Action <|-- DirtyFlagChange
Action <|-- MirrorChange
Action <|-- TargetLinkChange
Action <|-- TopologyChange
Effector --> Action
Action <--> Effect
@enduml